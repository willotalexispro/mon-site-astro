---
// LAYOUT : c'est le squelette HTML partagé par toutes les pages.
// Pense à ça comme ton "template de base" en HTML classique,
// sauf qu'au lieu de copier-coller le <head> et le <nav> partout,
// tu l'écris une seule fois ici.

// "Props" = les données que la page envoie au layout.
// Ici on attend un titre de page.
interface Props {
  titre: string;
}

// On récupère le titre envoyé par la page qui utilise ce layout
const { titre } = Astro.props;
const { MetaDescription } = Astro.props;
---

<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- {titre} injecte la valeur de la variable "titre" -->
  <title>{titre}</title>
  <meta name="description" content={MetaDescription}> 
</head>
<body>
  <div id="metaballs-bg"></div>
  <nav>
    <a href="/">Accueil</a>
    <a href="/a-propos">À propos</a>
    <a href="/projets">Projets</a>
    <a href="/blog">Blog</a>
  </nav>

  <main>
    <!-- <slot /> = "mets ici le contenu de la page" -->
    <!-- C'est comme un trou dans le template que chaque page remplit -->
    <slot />
  </main>

  <footer>
    <p>Mon premier site Astro &mdash; 2026</p>
  </footer>
</body>
</html>

<script>
  // ============================================================
  // CONFIGURATION METABALLS
  // Modifie ces valeurs pour personnaliser l'effet visuel.
  // ============================================================
  const METABALLS_CONFIG = {
    // -- Nombre et taille --
    count: 15,              // nombre de bulles
    radiusMin: 8,           // rayon minimum (px)
    radiusMax: 48,          // rayon maximum (px)
    radiusScale: 0.75,      // facteur appliqué au rayon pour le rendu (< 1 = plus petites)

    // -- Mouvement --
    speed: 2,               // vitesse max des bulles (px/frame)

    // -- Couleurs (format hex) --
    backgroundColor: '#081c37',  // couleur de fond (bleu foncé)

    // -- Contour / netteté --
    threshold: 0.99,        // seuil d'apparition (0.9 = plus flou/gros, 1.0 = plus net/petit)
    edgeSharpness: 100.0,   // netteté du bord (plus c'est haut, plus le contour est net)
  };

  // Convertit une couleur hex (#rrggbb) en vec3 GLSL "vec3(r, g, b)"
  function hexToGLSLVec3(hex) {
    var r = parseInt(hex.slice(1, 3), 16) / 255;
    var g = parseInt(hex.slice(3, 5), 16) / 255;
    var b = parseInt(hex.slice(5, 7), 16) / 255;
    return 'vec3(' + r.toFixed(3) + ', ' + g.toFixed(3) + ', ' + b.toFixed(3) + ')';
  }

  function initMetaballs() {
    var cfg = METABALLS_CONFIG;
    var container = document.getElementById('metaballs-bg');
    if (!container) return;

    var canvas = document.createElement('canvas');
    var width = canvas.width = window.innerWidth;
    var height = canvas.height = window.innerHeight;
    container.appendChild(canvas);

    var gl = canvas.getContext('webgl');
    if (!gl) return;

    var metaballs = [];
    for (var i = 0; i < cfg.count; i++) {
      var radius = Math.random() * (cfg.radiusMax - cfg.radiusMin) + cfg.radiusMin;
      metaballs.push({
        x: Math.random() * (width - 2 * radius) + radius,
        y: Math.random() * (height - 2 * radius) + radius,
        vx: (Math.random() - 0.5) * cfg.speed,
        vy: (Math.random() - 0.5) * cfg.speed,
        r: radius * cfg.radiusScale
      });
    }

    var bgColor = hexToGLSLVec3(cfg.backgroundColor);

    var vertexShaderSrc = `
    attribute vec2 position;
    void main() {
      gl_Position = vec4(position, 0.0, 1.0);
    }
    `;

    var fragmentShaderSrc = `
    precision highp float;
    const float WIDTH = ` + (width >> 0) + `.0;
    const float HEIGHT = ` + (height >> 0) + `.0;
    const float THRESHOLD = ` + cfg.threshold.toFixed(4) + `;
    const float EDGE_SHARPNESS = ` + cfg.edgeSharpness.toFixed(1) + `;
    uniform vec3 metaballs[` + cfg.count + `];
    void main(){
      float x = gl_FragCoord.x;
      float y = gl_FragCoord.y;
      float sum = 0.0;
      for (int i = 0; i < ` + cfg.count + `; i++) {
        vec3 metaball = metaballs[i];
        float dx = metaball.x - x;
        float dy = metaball.y - y;
        float radius = metaball.z;
        sum += (radius * radius) / (dx * dx + dy * dy);
      }
      if (sum >= THRESHOLD) {
        gl_FragColor = vec4(mix(vec3(x / WIDTH, y / HEIGHT, 1.0), ` + bgColor + `, max(0.0, 1.0 - (sum - THRESHOLD) * EDGE_SHARPNESS)), 1.0);
        return;
      }
      gl_FragColor = vec4(` + bgColor + `, 1.0);
    }
    `;

    var vertexShader = compileShader(vertexShaderSrc, gl.VERTEX_SHADER);
    var fragmentShader = compileShader(fragmentShaderSrc, gl.FRAGMENT_SHADER);

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    var vertexData = new Float32Array([
      -1.0,  1.0,
      -1.0, -1.0,
       1.0,  1.0,
       1.0, -1.0,
    ]);
    var vertexDataBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexDataBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

    var positionHandle = getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(positionHandle);
    gl.vertexAttribPointer(positionHandle, 2, gl.FLOAT, false, 2 * 4, 0);

    var metaballsHandle = gl.getUniformLocation(program, 'metaballs');

    var animationId;
    function loop() {
      for (var i = 0; i < cfg.count; i++) {
        var mb = metaballs[i];
        mb.x += mb.vx;
        mb.y += mb.vy;
        if (mb.x < mb.r || mb.x > width - mb.r) mb.vx *= -1;
        if (mb.y < mb.r || mb.y > height - mb.r) mb.vy *= -1;
      }

      var dataToSendToGPU = new Float32Array(3 * cfg.count);
      for (var i = 0; i < cfg.count; i++) {
        var baseIndex = 3 * i;
        var mb = metaballs[i];
        dataToSendToGPU[baseIndex + 0] = mb.x;
        dataToSendToGPU[baseIndex + 1] = mb.y;
        dataToSendToGPU[baseIndex + 2] = mb.r;
      }
      gl.uniform3fv(metaballsHandle, dataToSendToGPU);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      animationId = requestAnimationFrame(loop);
    }
    loop();

    window.addEventListener('resize', function() {
      if (animationId) cancelAnimationFrame(animationId);
      canvas.remove();
      container.innerHTML = '';
      initMetaballs();
    });

    function compileShader(shaderSource, shaderType) {
      var shader = gl.createShader(shaderType);
      gl.shaderSource(shader, shaderSource);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw 'Shader compile failed with: ' + gl.getShaderInfoLog(shader);
      }
      return shader;
    }

    function getAttribLocation(program, name) {
      var attributeLocation = gl.getAttribLocation(program, name);
      if (attributeLocation === -1) {
        throw 'Can not find attribute ' + name + '.';
      }
      return attributeLocation;
    }
  }

  initMetaballs();
</script>

<style>
  /* Le CSS dans un fichier .astro est automatiquement "scopé" :
     il ne s'applique QU'à ce composant, pas au reste du site.
     Très pratique pour éviter les conflits de styles. */

  body {
    font-family: system-ui, sans-serif;
    margin: 0;
    padding: 0;
    color: #e0e0e0;
    background: #081c37;
  }

  #metaballs-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
  }

  nav {
    position: relative;
    z-index: 1;
    display: flex;
    gap: 1.5rem;
    padding: 1rem 2rem;
    background: rgba(8, 28, 55, 0.85);
  }

  nav a {
    color: #e0e0e0;
    text-decoration: none;
  }

  nav a:hover {
    color: white;
    text-decoration: underline;
  }

  main {
    position: relative;
    z-index: 1;
    max-width: 960px;
    margin: 0 auto;
    padding: 0 1.5rem;
  }

  footer {
    position: relative;
    z-index: 1;
    text-align: center;
    padding: 2rem;
    color: #aaa;
    font-size: 0.85rem;
  }
</style>
