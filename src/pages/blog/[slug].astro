---
// PAGE DYNAMIQUE D'UN ARTICLE
// Le nom du fichier [slug].astro est spécial :
// les crochets [] disent à Astro "cette partie de l'URL est variable".
//
// Concrètement :
// - premier-article.md  → /blog/premier-article
// - deuxieme-article.md → /blog/deuxieme-article
//
// Astro crée automatiquement une page pour chaque fichier .md de la collection.

import BaseLayout from '../../layouts/BaseLayout.astro';
import BlocAuteur from '../../components/BlocAuteur.astro';
import { getCollection, render } from 'astro:content';
import { auteurs } from '../../data/auteurs';

// getStaticPaths() dit à Astro : "voici toutes les pages à générer".
// Pour chaque article, on crée un "path" avec le slug (le nom du fichier sans .md).
export async function getStaticPaths() {
  const articles = await getCollection('blog');
  return articles.map((article) => ({
    params: { slug: article.id.replace(/\.md$/, '') },
    props: { article },
  }));
}

// On récupère l'article correspondant à l'URL actuelle
const { article } = Astro.props;

// render() transforme le Markdown en HTML
const { Content } = await render(article);
const auteur = article.data.auteur ? auteurs[article.data.auteur] : undefined;
---

<BaseLayout titre={article.data.titre}>

  <nav class="breadcrumb" aria-label="Fil d'Ariane">
    <ol>
      <li><a href="/">Accueil</a></li>
      <li><a href="/blog">Blog</a></li>
      <li aria-current="page">{article.data.titre}</li>
    </ol>
  </nav>

  <h1>{article.data.titre}</h1>
  <p class="date">{article.data.date}</p>

  <!-- <Content /> affiche le Markdown converti en HTML -->
  <Content />

  {auteur && <BlocAuteur auteur={auteur} />}

</BaseLayout>

<style>
  .date {
    color: #888;
    font-size: 0.9rem;
    margin-top: -0.5rem;
  }

  a {
    color: #555;
    text-decoration: none;
  }

  a:hover {
    text-decoration: underline;
  }

  /* Breadcrumb */
  .breadcrumb ol {
    display: flex;
    flex-wrap: wrap;
    list-style: none;
    padding: 0.6rem 0;
    margin: 0 0 1rem 0;
    font-size: 0.9rem;
    gap: 0.3rem;
  }

  .breadcrumb li:not(:last-child)::after {
    content: '›';
    margin-left: 0.3rem;
    color: #aaa;
  }

  .breadcrumb li:last-child {
    color: #888;
  }

  .breadcrumb a {
    color: #4a90d9;
  }

  /* Checklist stylée */
  :global(.contains-task-list) {
    list-style: none;
    padding-left: 0;
  }

  :global(.task-list-item) {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.6rem 0.8rem;
    margin-bottom: 0.4rem;
    background: #f0f4f8;
    border-left: 3px solid #4a90d9;
    border-radius: 4px;
    font-size: 0.95rem;
  }

  :global(.task-list-item input[type="checkbox"]) {
    appearance: none;
    width: 1.15rem;
    height: 1.15rem;
    border: 2px solid #4a90d9;
    border-radius: 3px;
    flex-shrink: 0;
    cursor: pointer;
    position: relative;
  }

  :global(.task-list-item input[type="checkbox"]:checked) {
    background: #4a90d9;
  }

  :global(.task-list-item input[type="checkbox"]:checked::after) {
    content: '✓';
    color: white;
    font-size: 0.8rem;
    position: absolute;
    top: -1px;
    left: 2px;
  }
</style>
